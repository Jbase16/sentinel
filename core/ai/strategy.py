"""Module strategy: inline documentation for /Users/jason/Developer/sentinelforge/core/ai/strategy.py."""
#
# PURPOSE:
# Analyzes intercepted network traffic (from Ghost proxy) and uses AI to hypothesize
# specific attack vectors. Goes beyond pattern matching to "think like a hacker."
#
# WHAT IT DOES:
# - Examines HTTP requests captured by the proxy
# - Identifies parameters that might be vulnerable (IDs, flags, paths)
# - Uses AI to generate attack hypotheses (IDOR, SQLi, mass assignment, etc.)
# - Suggests specific payloads to test each hypothesis
#
# WHY AI FOR STRATEGY:
# - Recognizes subtle patterns humans might miss
# - Understands context (e.g., "user_id=5" in profile API → potential IDOR)
# - Generates creative test cases beyond wordlists
# - Learns from fine-tuned security knowledge
#
# KEY CONCEPTS:
# - IDOR (Insecure Direct Object Reference): Access other users' data by changing IDs
# - BOLA (Broken Object Level Authorization): Similar to IDOR but broader
# - Mass Assignment: Modify hidden object properties via API
# - Logic Vulnerabilities: Business logic flaws vs. technical bugs
#
# CIRCUIT BREAKER INTEGRATION:
# - AI calls are wrapped with asyncio.to_thread() to prevent blocking the event loop
# - Configurable timeout prevents hanging on slow AI responses
# - Falls back to heuristic analysis when AI is unavailable
#
# WORKFLOW:
# Ghost captures traffic → Strategy analyzes → Wraith executes test payloads
#

import json
import logging
import asyncio
import re
from typing import List, Dict, Optional
from dataclasses import dataclass

from core.ai.ai_engine import AIEngine
from core.base.session import ScanSession

logger = logging.getLogger(__name__)

# ============================================================================
# Configuration: Tunable parameters for AI call behavior
# ============================================================================
#
# AI_CALL_TIMEOUT: Maximum seconds to wait for AI response.
#   - 30 seconds is aggressive but prevents blocking the scan loop
#   - If AI takes longer, we fall back to heuristics
#   - This is SEPARATE from the 300s httpx timeout in OllamaClient
#   - Think of this as "how long are we willing to wait before giving up?"
#
AI_CALL_TIMEOUT = 30.0  # seconds


@dataclass
class AttackVector:
    """
    Represents a single attack hypothesis generated by AI or heuristics.

    Attributes:
        vuln_class: Category of vulnerability (IDOR, SQLi, XSS, etc.)
        parameter: The specific parameter being targeted
        hypothesis: Human-readable explanation of the attack theory
        suggested_payloads: Concrete test values to try
        source: Where this came from ("ai" or "heuristic")
    """
    vuln_class: str
    parameter: str
    hypothesis: str
    suggested_payloads: List[str]
    source: str = "ai"  # "ai" or "heuristic" - tracks provenance


class StrategyEngine:
    """
    Bridges the gap between Raw Traffic (Ghost) and Actionable Attacks (Wraith).

    This is the "Brain" that looks at captured HTTP traffic and generates
    attack hypotheses. It uses AI when available, but gracefully degrades
    to pattern-based heuristics when AI is unavailable or slow.

    LESSON: "Graceful Degradation"
    ───────────────────────────────
    A resilient system should NEVER hard-fail just because one component
    (like AI) is unavailable. Instead, it should:
    1. Try the optimal path (AI analysis)
    2. Fall back to a simpler path (heuristics)
    3. Log what happened so operators know
    4. Continue functioning with reduced capability
    """

    def __init__(self, session: ScanSession):
        """Initialize with a scan session for logging and findings storage."""
        self.session = session
        self.ai = AIEngine.instance()

    async def analyze_traffic(self, flow_data: Dict) -> List[AttackVector]:
        """
        Analyze a traffic snapshot and generate attack hypotheses.

        This method demonstrates "ASYNC TIMEOUT PATTERN":
        - We have a blocking function (AI call via httpx)
        - We want to call it from an async context
        - We DON'T want to block the event loop
        - We want a timeout shorter than the underlying call

        Solution: asyncio.wait_for() + asyncio.to_thread()

        Args:
            flow_data: Dict containing 'url', 'method', 'params', 'host'

        Returns:
            List of AttackVector hypotheses (may be empty if no vulnerabilities suspected)
        """
        url = flow_data.get("url", "")
        params = flow_data.get("params", [])
        method = flow_data.get("method", "GET")

        # No parameters = no logic fuzzing targets
        if not params:
            logger.debug("[Strategy] No parameters in request, skipping analysis")
            return []

        # Try AI first, fall back to heuristics
        if self.ai.client:
            try:
                vectors = await self._analyze_with_ai(flow_data)
                if vectors:
                    return vectors
                # AI returned empty - fall through to heuristics
                logger.debug("[Strategy] AI returned no vectors, trying heuristics")
            except asyncio.TimeoutError:
                logger.warning(f"[Strategy] AI call timed out after {AI_CALL_TIMEOUT}s, using heuristics")
            except Exception as e:
                logger.error(f"[Strategy] AI analysis failed: {e}, using heuristics")

        # Fallback: Heuristic analysis
        return self._analyze_heuristic(flow_data)

    async def _analyze_with_ai(self, flow_data: Dict) -> List[AttackVector]:
        """
        Send traffic data to AI for sophisticated analysis.

        LESSON: "Non-Blocking Sync Calls"
        ──────────────────────────────────
        The AI client uses httpx.Client (synchronous). If we call it directly
        in an async function, we BLOCK the entire event loop:

            # BAD - blocks event loop for up to 300 seconds!
            result = self.ai.client.generate(prompt, system)

        Solution: Run blocking code in a thread pool:

            # GOOD - runs in thread, doesn't block event loop
            result = await asyncio.to_thread(self.ai.client.generate, prompt, system)

        Then wrap with timeout:

            # EVEN BETTER - gives up after 30 seconds
            result = await asyncio.wait_for(
                asyncio.to_thread(self.ai.client.generate, prompt, system),
                timeout=30.0
            )
        """
        url = flow_data.get("url", "")
        params = flow_data.get("params", [])
        method = flow_data.get("method", "GET")

        system_prompt = (
            "You are a world-class Bug Bounty Hunter. "
            "Your goal is to inspect HTTP requests and deduce hidden vulnerability logic. "
            "Think like a hacker: Look for IDOR, BOLA, Mass Assignment, SQLi, and Command Injection. "
            "Return a JSON object with a key 'vectors' containing a list of objects with fields: "
            "'vuln_class', 'parameter', 'hypothesis', 'suggested_payloads'."
        )

        user_prompt = (
            f"Target Request:\n"
            f"Method: {method}\n"
            f"URL: {url}\n"
            f"Parameters: {params}\n\n"
            "Analyze this request structure. "
            "If these parameters look susceptible to logic attacks (e.g. IDs, debug flags, file paths), "
            "generate specific attack hypotheses."
        )

        logger.debug(f"[Strategy] Querying AI for {url[:50]}...")

        # ╔════════════════════════════════════════════════════════════════╗
        # ║  THE KEY FIX: Non-blocking AI call with timeout                ║
        # ╠════════════════════════════════════════════════════════════════╣
        # ║  asyncio.to_thread() - runs sync code in thread pool           ║
        # ║  asyncio.wait_for()  - adds timeout around the call            ║
        # ║  Together: non-blocking call that gives up after timeout       ║
        # ╚════════════════════════════════════════════════════════════════╝
        response_json = await asyncio.wait_for(
            asyncio.to_thread(self.ai.client.generate, user_prompt, system_prompt),
            timeout=AI_CALL_TIMEOUT
        )

        if not response_json:
            logger.debug("[Strategy] AI returned empty response")
            return []

        logger.debug(f"[Strategy] AI response received ({len(response_json)} chars)")

        # Parse JSON response
        try:
            data = json.loads(response_json)
        except json.JSONDecodeError as e:
            logger.warning(f"[Strategy] Failed to parse AI JSON: {e}")
            return []

        vectors_raw = data.get("vectors", [])
        logger.debug(f"[Strategy] AI generated {len(vectors_raw)} attack vectors")

        results = []
        for v in vectors_raw:
            vec = AttackVector(
                vuln_class=v.get("vuln_class", "Unknown"),
                parameter=v.get("parameter", "unknown"),
                hypothesis=v.get("hypothesis", "AI generated suspicion."),
                suggested_payloads=v.get("suggested_payloads", []),
                source="ai"
            )
            results.append(vec)
            self.session.log(f"[Neural Strategy] Proposed {vec.vuln_class} on {vec.parameter}")

        return results

    def _analyze_heuristic(self, flow_data: Dict) -> List[AttackVector]:
        """
        Pattern-based attack vector generation when AI is unavailable.

        LESSON: "Heuristics as Safety Net"
        ───────────────────────────────────
        Heuristics are simple rules that cover common cases. They're less
        intelligent than AI but:
        - ALWAYS available (no network dependency)
        - FAST (no API latency)
        - PREDICTABLE (same input → same output)
        - DEBUGGABLE (you can trace why a rule fired)

        This method looks for common vulnerability patterns:
        - Sequential IDs (user_id=1 → IDOR)
        - Privileged flags (admin=false, debug=0 → Privilege Escalation)
        - File paths (file=report.pdf → Path Traversal)
        - SQL-looking values (id=1' → SQLi)
        """
        url = flow_data.get("url", "")
        params = flow_data.get("params", [])
        method = flow_data.get("method", "GET")

        results = []

        # Pattern 1: Sequential numeric IDs → IDOR
        # If a parameter contains a numeric value and has a name suggesting identity
        id_patterns = re.compile(r'(user|account|profile|order|item|doc|file|record)[-_]?id', re.I)

        for param in params:
            param_name = param if isinstance(param, str) else str(param)

            # Check for ID-like parameters
            if id_patterns.search(param_name):
                results.append(AttackVector(
                    vuln_class="IDOR",
                    parameter=param_name,
                    hypothesis=f"Parameter '{param_name}' appears to be an object identifier. "
                               "Try incrementing/decrementing to access other users' data.",
                    suggested_payloads=["1", "0", "-1", "999999", "{{user_id-1}}", "{{user_id+1}}"],
                    source="heuristic"
                ))

            # Pattern 2: Privilege escalation flags
            priv_patterns = re.compile(r'(admin|role|is[-_]?admin|privilege|access[-_]?level|debug)', re.I)
            if priv_patterns.search(param_name):
                results.append(AttackVector(
                    vuln_class="Privilege_Escalation",
                    parameter=param_name,
                    hypothesis=f"Parameter '{param_name}' may control access level. "
                               "Try setting to privileged values.",
                    suggested_payloads=["true", "1", "admin", "root", "superuser"],
                    source="heuristic"
                ))

            # Pattern 3: File/path parameters → Path Traversal
            path_patterns = re.compile(r'(file|path|doc|template|include|page|url|src|dest)', re.I)
            if path_patterns.search(param_name):
                results.append(AttackVector(
                    vuln_class="Path_Traversal",
                    parameter=param_name,
                    hypothesis=f"Parameter '{param_name}' may accept file paths. "
                               "Test for directory traversal.",
                    suggested_payloads=[
                        "../etc/passwd",
                        "....//....//etc/passwd",
                        "..\\..\\..\\windows\\win.ini",
                        "/etc/passwd%00.pdf"
                    ],
                    source="heuristic"
                ))

            # Pattern 4: Search/filter parameters → SQLi
            sql_patterns = re.compile(r'(search|query|filter|sort|order|where|id|key)', re.I)
            if sql_patterns.search(param_name):
                results.append(AttackVector(
                    vuln_class="SQLi",
                    parameter=param_name,
                    hypothesis=f"Parameter '{param_name}' may be used in database queries. "
                               "Test for SQL injection.",
                    suggested_payloads=[
                        "' OR '1'='1",
                        "1; DROP TABLE users--",
                        "1 UNION SELECT NULL--",
                        "{{sleep(5)}}"
                    ],
                    source="heuristic"
                ))

        if results:
            logger.info(f"[Strategy] Heuristics generated {len(results)} attack vectors (AI unavailable)")
            for vec in results:
                self.session.log(f"[Heuristic Strategy] Proposed {vec.vuln_class} on {vec.parameter}")

        return results

    async def propose_attacks(self, flow_data: Dict):
        """
        High-level entry: Analyze traffic → Create findings → Trigger Wraith.

        This is the main entry point called by the Ghost proxy when it
        intercepts interesting traffic.
        """
        vectors = await self.analyze_traffic(flow_data)
        logger.debug(f"[Strategy] propose_attacks generated {len(vectors)} vectors")

        for vec in vectors:
            # Create a "Neural Finding" - a finding that is a HYPOTHESIS, not a fact.
            self.session.findings.add_finding({
                "tool": "neural_strategy",
                "type": f"hypothesis::{vec.vuln_class.lower()}",
                "severity": "MEDIUM",  # Hypotheses are medium until proven
                "target": flow_data.get("host", "unknown"),
                "value": vec.hypothesis,
                "metadata": {
                    "parameter": vec.parameter,
                    "payloads": vec.suggested_payloads,
                    "url": flow_data.get("url"),
                    "source": vec.source  # Track if AI or heuristic
                }
            })

            # TRIGGER WRAITH (The Hand) - Auto-verification of the hypothesis
            asyncio.create_task(self.session.wraith.on_hypothesis({
                "type": f"hypothesis::{vec.vuln_class.lower()}",
                "target": flow_data.get("host", "unknown"),
                "metadata": {"payloads": vec.suggested_payloads}
            }))
